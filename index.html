<html>

<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script type="text/javascript" src="chloroplethtime.js"></script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css" />
    <script src="https://code.jquery.com/jquery-1.9.1.js"></script>
    <script src="https://code.jquery.com/ui/1.10.2/jquery-ui.js"></script>

    <style>
        body * {
            font-family: 'Optima', sans-serif;
            /* text-align: center; */
            margin-left: auto;
            margin-right: auto;

        }

        p {
            background-color: rgba(156, 180, 224, 0.468);
            padding-top: 10;
            padding-bottom: 10;
        }
    </style>
</head>

<body>
    <h2 style="text-align: center;">Number of People Fully Vaccinated for COVID-19 from Jan 2021 to Nov 2021</h2>
    <div id="vis1" style="display: block;"></div>
    <p style=" text-align: center;">
        <label for="amount">Date slider:</label>
        <input type="range" id='slider' step="86400"></input>
    <h4>Key</h4>
    <ul id="list">
    </ul>

    </p>

    <script>
        chgraphtime();
        async function getAverageByState() {
            let countyIncome = d3.csv('kaggle_income.csv', d3.autoType).then(countyIncome => {
                let states = new Set(d3.map(countyIncome, d => d['State_ab']));
                let statesIncome = [];

                countyIncome.forEach((d, i) => {
                    d.Median = Number(d.Median)
                });
                states.forEach(d => {
                    let sum = 0;
                    let i = d3.filter(countyIncome, c => {
                        return c['State_ab'] === d;
                    });
                    i.forEach(c => {
                        sum = sum + c['Median'];
                    })
                    //  console.log(sum)
                    statesIncome.push({ state: d, income: sum / i.length });
                });
                console.log(statesIncome);
                return statesIncome;
            });
        }
    </script>

    <h2>Median Income by State</h4>
        <p>
            <svg id="jkm253" height=350 width=725 style="margin: 20px" /></svg>
        </p>
        <h4>Key: Median Income</h4>
        <ul id="legend">
        </ul>

        <script id="jkm253">


            // Data filtering for average median income per state
            let getData = async function () {
                let countyIncome = d3.csv('kaggle_income.csv', d3.autoType).then(countyIncome => {
                    let states = new Set(d3.map(countyIncome, d => d['State_Name']));
                    let statesIncome = [];

                    countyIncome.forEach((d, i) => {
                        d.Median = Number(d.Median)
                    });
                    states.forEach(d => {
                        let sum = 0;
                        let i = d3.filter(countyIncome, c => {
                            return c['State_Name'] === d;
                        });
                        i.forEach(c => {
                            sum = sum + c['Median'];
                        })
                        //  console.log(sum)
                        statesIncome.push({ state: d, income: sum / i.length });
                    });
                    console.log(statesIncome)


                    //=============================================================================================
                    //############################# Jade's Graph #################################################
                    //=============================================================================================
                    let state_data = d3.json('us_states.json', d3.autoType).then(state_data => {
                        var state_income = statesIncome;

                        let svg = d3.select("svg#jkm253");
                        let svgWidth = svg.attr("width");
                        let svgHeight = svg.attr("height");

                        let states = topojson.feature(state_data, state_data.objects.states);
                        let statesMesh = topojson.mesh(state_data, state_data.objects.states);
                        let usMesh = topojson.mesh(state_data, state_data.objects.nation);

                        let projection = d3.geoAlbersUsa().fitSize([svgWidth, svgHeight], states);
                        var path = d3.geoPath().projection(projection);

                        let colorArray = ["#0d06aa", "#0055d5", "#1eabd0", "#00d4a1", "#6aff45"];

                        for (var i = 0; i < state_income.length; i++) {
                            let per = state_data.objects.states.geometries;
                            let arr_state = state_income[i].state;
                            let arr_income = state_income[i].income;

                            for (var j = 0; j < per.length; j++) {
                                var json_state = per[j].properties.name;
                                if (arr_state == json_state) {
                                    per[j].properties.value = arr_income;
                                    break;
                                };
                            };
                        };

                        incomeExtent = d3.extent(state_income, d => d['income']);

                        let colorScale = d3.scaleQuantile()
                            .domain(incomeExtent)
                            .range(colorArray);

                        svg.selectAll("path.states")
                            .data(states.features)
                            .join("path")
                            .attr("class", "states")
                            .attr("d", path)
                            .style("fill", d => colorScale(d.properties.value));

                        svg.append("path")
                            .datum(statesMesh)
                            .attr("class", "outline")
                            .attr("d", path)
                            .style("stroke-width", 1)
                            .style("stroke", "white")
                            .style("fill", "none");

                        svg.append("path")
                            .datum(usMesh)
                            .attr("class", "outline")
                            .attr("d", path)
                            .style("stroke-width", 3)
                            .style("stroke", "darkgrey")
                            .style("fill", "none");

                        let thresholds = colorScale.quantiles();
                        console.log(thresholds);

                        let list = d3.select("ul#legend");

                        thresholds.forEach(elem => {
                            list.append("li")
                                .attr("class", "bullet-text")
                                .text("Up to " + d3.format("($.0s")(elem))
                        });

                        let tooltipWidth = 100;
                        let tooltipHeight = 25;

                        let moMesh = svg.append("path")
                            .attr("class", "mouseOutline");

                        let tooltip = svg.append("g")
                            .attr("class", "tooltip")
                            .attr("visibility", "hidden");

                        tooltip.append("rect")
                            .attr("fill", "black")
                            .attr("opacity", 0.9)
                            .attr("x", -tooltipWidth / 2.0)
                            .attr("y", 0)
                            .attr("width", tooltipWidth)
                            .attr("height", tooltipHeight)

                        let labelName = tooltip.append("text")
                            .attr("fill", "white")
                            .attr("text-anchor", "middle")
                            .attr("alignment-baseline", "hanging")
                            .attr("x", 0)
                            .attr("y", 1);

                        let labelValue = tooltip.append("text")
                            .attr("fill", "white")
                            .attr("text-anchor", "middle")
                            .attr("alignment-baseline", "hanging")
                            .attr("x", 0)
                            .attr("y", 20);

                        d3.selectAll(".states").on("mouseenter", mouseEntersPlot);
                        d3.selectAll(".states").on("mouseout", mouseLeavesPlot);

                        function mouseEntersPlot() {
                            tooltip.style("visibility", "visible")
                            let state = d3.select(this);
                            let stateName = state.datum().name;
                            labelName.text("hi");
                            labelValue.text(hey);

                            let bounds = path.bounds(state.datum());
                            let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
                            let yPos = bounds[1][1] - 15;
                            tooltip.attr("transform", `translate(${xPos},${yPos})`);
                            /**var mo = topojson.mesh(us, us.objects.states, function(a, b) { return a.id === stateID || b.id === stateID; });
                            momesh.datum(mo).attr("d", path)**/



                            // You can use the geoPath() generator to do all sorts of helpful things
                            // let centroid = path.centroid( state.datum() );  // Get the pixel "center" of the state
                            // Get the pixel boundaries of the state
                            // In both cases here, the geoPath() is parsing the fancy topoJSON data to figure out pixels using the projection

                            // Place it at the bottom of the state, centered


                            // Transform the <g> group so that everything moves together easily


                            // To fix the oscillation, we add this in the CSS for .mouseover
                            //  pointer-events: none;

                            // Technically, the right way to do this is with another mesh for some complicated reasons
                            //  You have to use the second parameter of topojson.mesh() to pick out this state's boundaries
                            // At the end of the lecture we tried this out
                            //  First, make a new mesh with a filter for only borders of the current state

                            //  Then apply it to your special mesh that's on top of everything else





                        }
                        /**
                            function mouseLeavesPlot() {
                        
                             // Hide when you leave a state
                             tooltip.style("visibility","hidden");
                        
                             let state = d3.select(this);
                        
                             // Reset old style mouseover stroke
                             // state.attr("stroke","none")
                             //      .attr("stroke-width", 0);
                             // }
                        
                             // Here we are hiding the mouseover mesh we added at the end of the lecture
                             momesh.attr("d", "");
                        
                           }**/


                    });



                });


            }

            getData();



        </script>
</body>

</html>